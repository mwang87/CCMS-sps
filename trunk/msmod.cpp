/*
 * Mass-spectrometry clustering Project
 * This program is property of University of California at San Diego
 *
 * Supervisor: Pavel Pevzner
 * collaborator: Nuno Bandeira
 * coded by Dumitru Brinza
 *
 * ppevzner@cs.ucsd.edu
 * dima@cs.ucsd.edu
 *
 * msmod version released on April 26, 2009
 */

#define HELPMESSAGE "                                                          \n\
                                                                               \n\
Error: Invalid number of parameters.                                           \n\
                                                                               \n\
msmod takes as input a set of spectra, their annotations generated by SpecNet, \n\
and protein database. It floats modifications in order to maximize explained   \n\
intensities. It outputs a set of new annotations.                              \n\
                                                                               \n\
Usage:                                                                         \n\
./msmod <spec_file_bin> <annotation_file> <protein_db> <output_file> [-options]\n\
                                                                               \n\
spec_file_bin   - binary file with all spectra and their intensities           \n\
annotation_file - file with spectrum annotations generated by SpecNet          \n\
protein_db      - protein db in fasta format                                   \n\
	                                                                             \n\
output_file     - name of the output file, outputs floated annotations from    \n\
                  annotation_file.                                             \n\
                                                                               \n\
options:                                                                       \n\
-top K   -  output top K scorring candidates (Default K=1)                     \n\
-var     -  number of positions allowed to float to the left/right for each    \n\
            modification, default 3.                                           \n\
-maxmods -  annotations containing more than maxmods number of modifications   \n\
            are not floated, default 3.                                        \n\
-start   -  annotations corresponding to spectra with ids >= start are floated \n\
-finish  -  annotations corresponding to spectra with ids < finish are floated "



#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <list>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <sstream>
#include "FloatMods.h"

// This is an example of using floating code

using namespace std;

//---------------------------------------------------------------------------------

void   ReadBinarySpectra(string FileName, vector<spectra> & all_spectra);
int    ReadSpecNetPeptides(string * mms_peptides, string FileName);
void   ReadGenome(string & genome, string & genome_orig, string FileName, TDB_Title & dbt);

//---------------------------------------------------------------------------------

int main(int argc, char *argv[])
{

  if(argc<4) { cout << HELPMESSAGE << endl; exit(1);}

  int argi = 1;
  string SpecFileName = argv[argi++];
  string SpecNetFile  = argv[argi++];
  string DataBaseFile = argv[argi++];
  string OutPutFile = argv[argi++];
  int    topK         = 1;
  int    variation    = 3;
  int    MaxMods      = 3;
  long   start_id     = 0;
  long   finish_id    = 999999999;

   while (argi < argc) {
         if (strcmp(argv[argi], "-var") == 0) {
      variation = atoi(argv[++argi]);
    }
    else if (strcmp(argv[argi], "-top") == 0) {
      topK = atoi(argv[++argi]);
    }
    else if (strcmp(argv[argi], "-maxmods") == 0) {
      MaxMods = atoi(argv[++argi]);
    }
    else if (strcmp(argv[argi], "-start") == 0) {
      start_id = atoi(argv[++argi]);
    }
    else if (strcmp(argv[argi], "-finish") == 0) {
      finish_id = atoi(argv[++argi]);
    }
    else {
          cout << HELPMESSAGE << endl; exit(1);
    }
    ++argi;
  }


  // loading spectra into memory
  cout << "Reading all spectra " << argv[1] << " ... " << endl;
  vector<spectra> all_spectra;
  ReadBinarySpectra(SpecFileName.c_str(),all_spectra);
  int NUMBER_OF_SPECTRA = all_spectra.size();
  cout << NUMBER_OF_SPECTRA << " spectra ok"<< endl;

  // loading SpecNet peptides into memory
  string * mms_peptides = new string[NUMBER_OF_SPECTRA];
  cout << "Reading Spectral Networks peptides ..."; cout.flush();
  for(int i=0;i<NUMBER_OF_SPECTRA;i++) mms_peptides[i]="";
  ReadSpecNetPeptides(mms_peptides, SpecNetFile.c_str());


  // loading protein database, database is one long string, proteins in the
  // database are separated by space, unknown are X

   TDB_Title dbt;
   string genome = "", genome_orig = "";
   cout << "Reading protein database ..."; cout.flush();
   ReadGenome(genome, genome_orig, DataBaseFile.c_str(), dbt);
   cout << genome.length() << endl;

   ofstream ostr;
	 ostr.open(OutPutFile.c_str(), ios::binary);

  // Floating call

   TFloatMods ModFloat(genome, genome_orig, topK);

   for(int i=start_id;(i<finish_id&&i<NUMBER_OF_SPECTRA);i++)
   {
    if(mms_peptides[i]!="")
    {
     ostr << i;/* << "\t"<< mms_peptides[i];*/ ostr.flush();

      vector<string> list;
      int mappos = -1;
      ModFloat.FloatMods(mms_peptides[i],variation,MaxMods,&(all_spectra[i]), list, mappos);
      string dbseq = (mappos<0?"":dbt.get(mappos));
      ostr << "\t" << list[0] << "\t" <<  dbseq << endl;

      for(int j=1;j<list.size();j++) ostr << i <<  "\t" << list[j] << "\t" <<  dbseq << endl;
    }
   }

  ostr.close();
  return 0;
}
//---------------------------------------------------------------------

void ReadBinarySpectra(string FileName, vector<spectra> & all_spectra)
{
    unsigned int num_spectra;
    fstream myFile (FileName.c_str(), ios::in |  ios::binary);

    myFile.seekg (0);
    myFile.read ((char*)&num_spectra, sizeof (int));

    for(int i=0;i<num_spectra;i++) all_spectra.push_back(spectra());

    short int *num_of_peaks_in_spectra = new short int[num_spectra];
    myFile.read ((char*)num_of_peaks_in_spectra, num_spectra * sizeof (short int));

    for(int j = 0;j<num_spectra;j++)
    {
    	all_spectra[j].total_intensity = 0;
    	all_spectra[j].n_peaks = num_of_peaks_in_spectra[j];

    	all_spectra[j].spectrum = new peak[((int)all_spectra[j].n_peaks)];
     //this line skips first line in spectra corresponding to charge
     myFile.read ((char*)(&all_spectra[j].spectrum[0]), sizeof (peak));
     all_spectra[j].parent_mass = all_spectra[j].spectrum[0].mass;

     for(int i = 0;i<all_spectra[j].n_peaks;i++)
     {
      myFile.read ((char*)(&all_spectra[j].spectrum[i]), sizeof (peak));
  	 // cout << all_spectra[j].spectrum[i].mass << " " << all_spectra[j].spectrum[i].intensity << endl;
      all_spectra[j].total_intensity += all_spectra[j].spectrum[i].intensity;
     }

    }
    delete [] num_of_peaks_in_spectra;

}

// Notice Input assumes that indexes are 1 based
//---------------------------------------------------------------------------------
int ReadSpecNetPeptides(string * mms_peptides, string FileName){

  	   ifstream infile;
  	   infile.open(FileName.c_str(), ios::binary);

  	   if (!infile) {
  	        cerr << "Unable to read " <<  FileName << endl;
  	        exit(1);
  	    }
       string line;
        string::size_type loc1,loc2,loc3;
  	   int k=0;
  	  getline(infile, line);
  	   while(getline(infile, line))
  	    {
  	        loc1 = line.find( "\t", 0 );
  	        loc2 = line.find( "\t", loc1+1 );
  	        loc2 = line.find( "\t", loc2+1 );
  	        loc3 = line.find( "\t", loc2+1 );
  	       // cout << loc3 << " " << loc2 << " " << loc3-loc2-1 << endl;
  	        if(loc3-loc2-1>0) {
  	        string PEP = line.substr(loc2+1,loc3-loc2-1);
            //for(int i=0;i<PEP.length();i++) if(PEP[i]=='Q') PEP[i]='K'; else if(PEP[i]=='I') PEP[i]='L';
  	        mms_peptides[atoi(line.substr(loc1+1).c_str()) - 1]=PEP; // remove -1 if 0 based
  	        }
  	        k++;
  	    }
  	   infile.close();
  	   return k;
}
//---------------------------------------------------------------------------------

void ReadGenome(string & genome, string & genome_orig, string FileName, TDB_Title & dbt){

	ifstream infile;
	infile.open(FileName.c_str(), ios::binary);

	if (!infile) {
        cerr << "Unable to read " <<  FileName << endl;
        exit(1);
    }
   genome_orig = " ";
   string line;
   while(getline(infile, line))
          if(line.length()>1){
          if(line[0]!='>'){
          int i = line.length();
          while(line[--i]<'A' || line[i]>'Z');
          genome_orig+=line.substr(0,i+1);
          } else {dbt.set(line.substr(1),genome_orig.length()); genome_orig+=" ";}
          }
   genome_orig+= " ";
   infile.close();
   genome = genome_orig;
   for(int i=0;i<genome.length();i++) if(genome[i]=='Q') genome[i]='K'; else if(genome[i]=='I') genome[i]='L';
}
//--------------------------------------------------------------


